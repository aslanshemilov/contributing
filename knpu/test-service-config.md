# Test Service Config

Coming soon...

Of course, when you make a prayer request to symphony the, you almost always need a test. All symphony is a heavily tested library to guarantee quality, so we're definitely gonna need a test for this new target path helper, but how do we run the symphony tests? Well, I'm happy to report this is a super smooth process inside of the go to your terminal that's in the. If you look inside of your Sydney directory, it has a composer that Jason, this actually describes all the libraries. That symphony itself depends on in order to function, in order to run the 

tests, 

to run the test, go and say, start first, run composer update. One important thing here is that you'll notice there's not a composer dot lock file inside the repository. That's a common practice for libraries. They commit the composed that Jason Bio, but they don't commit the composers that lock file. That's different than applications. So before you run your tests, you want to make sure run composer update so that it reads the compose that Jason File in Dallas. Dependencies. Sure, you could run composer install because there's no lock file, so it would do the same thing, but in case in case there was a composer of that locked file because you had already run composer update before, but by running composer update, it makes sure that we always get the latest stuff. Even if we have a composer dot lock file already from having previously run this command because you'll see when this finishes. Yeah, now we do have a composer dot lock file. All right, turn the test. It is that slash php unit. That's it. This is a wrapper around symphony that helps them make helps. Make sure you have the stuff that you need, balance some other dependencies and do a different directory. 

There's one time and then starts running your tests. There are a lot of tests, so I'm actually going to control seed this. I usually don't run all the tests locally. As you'll see in a few minutes. Symphony has continuous integration, so once you make your poll request, it will run all the tests, but it is really convenient because we can target the specific directory that we want. So let's run all the tests from security bundle. 

If you don't fast forward, like I didn't, you might see a couple of it might take a minute or two and everything passes. There are a couple skipped tests. That's probably because our local computer lacks some php extension or other other thing that those tests need to run, nothing to worry about. So now we can add our test to actually make sure things work. Alright. So let's go back into our security bundle, a double click into it. Since we want to test the target path. Halbert trait will go into tests security and create a new php class called target path help or test. This will extend the normal symphony, the normal test case from PHP unit. Well, they'll say a public function test save path for the body of this test. Since this is not a testing tutorial, actually going to paste in some code that I have and then auto complete. A few use statements like the firewall map from security bundle to finish our test firewall config is the last one. 

Oh, 

and target half helper. The target helper upperclass doesn't really do anything, it just all flows most of the work to a trait, so what this test effectively does is create several different mocks. It creates a firewall config that returns a firewall name as the firewall name, and then ultimately make sure that this special key is what is set to this special keys in on the session is set to the url that we passed the safe path. If you want to understand this better, look into it further, but this is no different than a unit test that you had created for your code because you have a test. Have nothing to do with the framework. We're just testing a class at a very low level. It's make sure as fast as let's go back and actually target this class directly and awesome. It works 

this point. We have a fully functional target path helper class, but if someone uses the security bundle, this is not yet registered as a service. They would have to register themselves. We want to do that for them. So if you look in security, bundled dependency injection security extension, you'll see that this class loads a number of xml files which add all of the services for this bundle. And if you look in the resources config directory and open security that xml around lines 136, you start saying these security firewall map, that's the class, that's the service we depend on. And the firewall config, another class we depend on. So one of the questions is which xml files most appropriate for our new target bath helper. Since it relates to the firewall map and the firewall config, I think that this file's probably most important, but somebody can always tell us that we're wrong later. So let's create a new service for the ID. Let's give it security, that target path to treat. And for the name I'm just trying my best to follow existing a naming conventions inside of here. Oh, not target draft trait, but target path 

helper so that the class to target for the class. I'll cheat paste part of the previous one as a target path helper. Then inside of here we're going to need three different arguments, the session firewall map and request ACC, so we'll say argument type equals service ID equals session. By the way, even though I'm inside of the Symphony Library itself, I'm actually going to go into my settings search for symphony and enable the plugin for this project. That's actually going to give me a little bit of help here. Or maybe not. Nevermind that argument type equals service ID equals in this case we need the firewall map. So that is this id up here, security that firewall, that map. And the last thing is we need argument type equals service ID equals request stack and that should be it. Now we've registered as a service, but there's still one piece missing and that is that in order for our secure target path helper to be Ottawa, Arabelle like as an argument here, we need to add an alias from that class to the service ID is similar to the example given down here for the firewall map. 

So the way this is done is by saying service ID equals and the way you use the full long class into our library. And I'll say ID equals. 

Oh, 

and they'll say alias equals copy the ID name, service ID, and that's it. So now the target by the helper should be auto Arabelle in any way, shape, or form. And that's it. We've created the class, we've created the task, we've registered as a service, we've given an Ottawa alias. Our pull request is ready. Now, the one thing that I would recommend during the I am not going to do, because we already talked about how to do it earlier, is too great a new symphony project. Poll our patch into that symphony project and actually test to make sure this stuff really works. Our classes tested, our class does have a test, but that doesn't always mean that there's not a bug in there. And our service configuration actually isn't tested. So if there's a bug in here, it wouldn't be very obvious at all saying that you actually tried your patch in a real project, goes a long way to helping your poor quest to get merged. So next, let's actually commit this and get it up to get hub at a poll request and hope the best.