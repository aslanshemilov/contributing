# Pr Create Class

Coming soon...

You've already helped along and issue a part of class and even opened up our own really good issue, but of course the biggest thing you can do a symphony is actually make a pull request maybe to fix some bug you found or some feature. Let's look at an existing issue. Its number is 27, eight, eight, three five. This comes from the security components, so you may or may not be familiar with that basically. 

Okay. 

Whenever you try to access a protected page as an anonymous user, if you're not logged in the you or are you try to go do a save to a key in the session and then you're redirected to the login page. Then after you log in, that key is read from the session and you're redirected back there. Sometimes it can be useful for you to manually set, uh, you were out into that session key. And to help with that symphony has a treat called target pap trait. 

Okay? 

That helps you. It gives you a method called save target path. You basically give it to you or I that you want to store in the session. In this store is at any various in the, in this specific session key, that's where symphony looks later to read that key. The problem is that this user wants to set that value from a controller, 

but 

that's fine, except he noticed that this has this thing called the provider key. That's actually the name of your firewall, which if you want, you can just hard code. If you have multiple firewalls, it's better to actually detect which firewall is being created, which firewall you're currently using. Anyways, in a recent version of symphony, this firewall can fig feature was added where you can use a service called firewall map called get firewall, config pass the request call, get named, and you get your firewall name. The problem is that the firewall map is not actually something that you can auto wire and one of our core contributors gives a reason behind that. Down here you couldn't make this service auto wire by adding this alias, but it's probably not something we should do. And Stephanie Court. So I was thinking about this problem and I thought, what if we, in addition to the target path trade added a new class called target pap helper that you could use to easily save or get the target path without needing to use the private provider key. We'd be able to do this because we could inject the firewall map into that new class so at the end user can just use our new class and not have to worry about anything else. If you're not completely following me yet, don't worry. The important thing is the process we're going to go through to create this. So 

in order to create this, I'm going to go over Petri storm and actually move into the symphony director, Dri directly that we've been working on. Then I'm gonna go over my tab where I have symphony open and right now we're still on the French from Collin Odell before. I'm going to make sure that I'm up to date by saying get back to origin. Then when I create a new branch with get checkout Dash B, 

target path helper origin master. So I'm creating a new branch based off of symphonies master branch. Now. Well, this is actually important. Whenever you make a pull request, you're either adding a feature or fixing a bug. If you're adding a feature, you should always make it against the master branch, then it will be included in the next symphony minor released in this case in symphony four point two. But if you're fixing a bug, you should fix that in the oldest supported branch. So for example, if you found a bug that was introduced in symphony three point four, you don't want to create your branch based off of origin slash three point four. 

Okay? 

Now the only tricky part about that is, for example, if a bug we're introduced in symphony three point two, you wouldn't actually make the pull request against the three point two branch because three point two is no longer supportive to help with this. You can go to Sydney.com/roadmap. So if you discovered there was a bug that was introduced to simply write down here, you can see that the only supportive branches right now are two point eight, three point four and four point one. So very simply you'll find if a bug was introduced in three point two, it means just fix it in three point four, a bug when it was introduced in two point seven, you fix it in two point eight. Anyways, in this case, we want to create our new branch off of origin master. Perfect. All right. The next question is where should this new target pap helper class live? If I do shifts shifts and do target path trait, you can see that this lives inside of the security component. I'll double click on the directory to move to it. Now the target pad helper actually needs to live instead in security bundle, and this is a subtle issue and if you started coding you wouldn't realize it. The problem and the reason 

is that the firewall math class that we want is actually a class that comes from the security bundle. So because our new classes going to use a classroom security bundle, it needs to live in the security bundle classes in anything instead of a component can only rely on other component classes, not other classes in a bundle. So I'm going to go into bundle security bundle and we'll open up security and yeah, actually there's a firewall map and firewalking fit class. They were seeing still quite a new php class called firewall called target path helper. And then to start we'll do public function and let's just call the methods save path and here's how I want it to work. I want to be able to pass the Uri and it will say that automatically into the correct session to eat in. If you're making a poor custom master branch and the massive branch does support species, it's lowest php version seven point one. So you can and should use scalar type events. However, we do not use the void of return type at at this time. Of course, since this is a new public function, we should add some page for documentation to describe what it does. So I'll say, so that's the target path the user should be redirected to after authentication. 

Now one thing is the Symphony Korea find is that we don't actually have a lot of peachtree documentation because we don't want to maintain having too much documentation right inside of the code. So because I had a string type and here it's actually redundant heavy APP program and a lot of cases they'll remove it. Now I'm going to keep it because I actually want to add a little bit more information here and say that you were I to set as the target path, but even that is debatable. That's a pretty obvious description. So if I don't want this description, I would actually remove the APP ram entirely. By the way, those are details not to worry too much about because someone will help you out on your pull request if you do something that's not exactly to the standard. The other thing that you'll have at the top of every single class in a simply is the copyright header. So I'll put that on top and we are ready to go. Okay. So we ultimately behind the scenes to make our job easier, I'm actually going to use this target path trait from inside of our new target path helper. So I'll say use target path trait, and then inside safe path we're ultimately going to call save target path. And here's the tricky thing, we need to pass 

three different arguments, the session to provider key, which is the fire walkie and the Uri. Now we know that to get the provider key, we can use this firewall service. So this means that we need the session and the firewall map to be injected as constructor arguments. So I'll type in session interface session firewall map, and those are two firewall maps. This is pretty common. We want the one from security fundal. And the reason is that if you open the firewall map from security bundle, it actually contains this get firewalking fig method. It 

no, I'm not going to that. 

That's the one actually used inside of symphony. Then I'll hit alt enter to initialize those two fields and we do not need the APP bar above each property because that is, that is obvious based on the constructor. Now, to calculate the provider key that we want, I'm going to create a new private function called get provider key and it's going to return a string and I'm just going to put for now a little to do there. And in say target path, we can now pass this, this era session, this Arrow get provider key and the Uri. Awesome. In this case, I'm on key provider. Can you notice I'm not using the peach documentation? That's for two reasons. One, this is a private function, so we don't typically document those. And the second thing is we already have the return type right here, so don't need to duplicate that above. 

Alright, finally, let's fill in this gift provider key and to do that you can see we can call them at that on a firewall map called get firewall config. Pass the request and getting it. So I'm first going to say firewall config equals this Arrow firewall map, carol, get firewalking fig. Now the tricky part here is that we actually need to request object, which we don't currently have inside of this class. So that's not a problem. To get that, we're actually going to dependency and Jackie beat request stack. I'll hit enter again to make that another argument. Queen things up and there we go and pass it down here. Now normally when you use the request back, you said this air request dot get your get current request. In this case, the firewall symphonies security firewall only operates on the outer master request. So I think we actually want to hear is called get mastery request. I'm not actually 100 percent sure about that. That's a small detail, but that's okay. Putting up on and pull request is going to give people the opportunity to comment on that. All right. If you look at get firewall config, it's actually possible for this to return. No, we need a code for that. So if not equals a firewall config can be this Yoda conditional here. We have this backwards. That's another symphony coding standard, but if you get, if you don't know that seriously, not a problem, we'll say throw new logic. Exception doesn't really matter which class one exception you throw. If somebody wants a different one, I'll tell you, 

I'm gonna. Say I could not find firewall config for the current request and finally at the bottom we'll return firewalking fig Arrow, get name and that should be yet. While we're here, let's add one more function called yet path that will return a string in here. We'll return this Arrow, get target path, this era session, this Arrow get provider key to fill in those two arguments. In this case, I am in Ad Petri documentation. I'm not going to have the return string that's redundant, but I am going to say turns the url if any the user visited that forced them to log in. 

Hmm. 

I'll put a period on the end of that as we usually do and descriptions. All right. The last thing I'm gonna do with this class, we still have a couple more steps to do like writing the test and adding this as a service. The last thing I do with this class is actually add a final key word. That final keyword means that no one is allowed to subclass this, and by default in this is typically something that we want in symphony because helps protect it helps make supporting backwards compatibility easier in the future by knowing that no one is subclass in this, we can change certain functions in it without breaking backwards compatibility. Now, if there is a legitimate use case for some of the subclasses, then you don't need final finals. A good default to have because we can always remove it later. All right, next, let's actually write a test for this class. Get symphonies tests running, and then it makes sure that this is registered as a as a service. Then we'll make our very first poor quest.